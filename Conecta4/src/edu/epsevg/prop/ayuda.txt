import numpy as np

def heuristica_conecta4(tablero, jugador=1):
    filas, columnas = tablero.shape
    puntajes = [0] * columnas  # Puntaje para cada columna
    
    def contar_alianzas(tablero, fila, col, delta_fila, delta_col, jugador):
        # Cuenta la cantidad de fichas consecutivas de 'jugador' en la dirección dada
        cuenta = 0
        for i in range(4):
            r = fila + i * delta_fila
            c = col + i * delta_col
            if 0 <= r < filas and 0 <= c < columnas and tablero[r][c] == jugador:
                cuenta += 1
            else:
                break
        return cuenta

    # Evaluar cada columna
    for col in range(columnas):
        # Buscar la primera fila disponible en la columna
        fila_disponible = -1
        for fila in range(filas):
            if tablero[fila][col] == 0:
                fila_disponible = fila
                break

        # Si la columna está llena, seguimos a la siguiente
        if fila_disponible == -1:
            puntajes[col] = -np.inf  # Penalización para columnas llenas
            continue

        # Simulamos poner la ficha del jugador en la columna
        tablero[fila_disponible][col] = jugador

        # Evaluamos la posición resultante
        puntuacion_columna = 0

        # 1. Alineaciones propias y del rival
        for delta_fila, delta_col in [(1, 0), (0, 1), (1, 1), (1, -1)]:
            cuenta_jugador = contar_alianzas(tablero, fila_disponible, col, delta_fila, delta_col, jugador)
            cuenta_rival = contar_alianzas(tablero, fila_disponible, col, delta_fila, delta_col, -jugador)

            if cuenta_jugador == 4:
                puntuacion_columna += 10000  # Victoria segura
            elif cuenta_jugador == 3:
                puntuacion_columna += 100  # Opción de 3 en línea
            elif cuenta_jugador == 2:
                puntuacion_columna += 10  # Opción de 2 en línea

            if cuenta_rival == 4:
                puntuacion_columna += 9000  # Bloqueo de victoria del oponente
            elif cuenta_rival == 3:
                puntuacion_columna += 90  # Bloqueo de 3 en línea del oponente
            elif cuenta_rival == 2:
                puntuacion_columna += 9  # Bloqueo de 2 en línea del oponente

        # 2. Prioridad al centro
        puntuacion_columna += 6 - abs(3 - col)  # Da más puntos a columnas centrales

        # Deshacemos el movimiento
        tablero[fila_disponible][col] = 0

        # Guardamos el puntaje de la columna
        puntajes[col] = puntuacion_columna

    # Selecciona la columna con el puntaje máximo
    mejor_columna = np.argmax(puntajes)
    return mejor_columna, puntajes
